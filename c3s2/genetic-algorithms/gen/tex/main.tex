\documentclass[a4paper, 12pt]{article}
\input{../../sty/use.sty}
\input{../../sty/th.sty}
\input{../../sty/cmd.sty}
\input{../../sty/cover.sty}

\author{Скибицький Нікіта}
\date{\today}

\allowdisplaybreaks
\numberwithin{equation}{section}
\linespread{1.15}

\begin{document}

\cover{2}{Генетичний алгоритм}

\tableofcontents

\section{Неформальний опис алгоритму}

\subsection{Власне опис}

У генетичному алгоритмі популяція розв'язків-кандидатів (яких будемо називати особинами) оптимізаційної задачі еволюціонує до кращого розв'язку. Кожен кандидат характеризується множиною властивостей (це його хромосоми або генотип), які можуть мутувати. За традицією генотипи позначаються як бінарні рядки з 0 і 1, але інші кодування також можливі.

\subsection{Історія винаходу методу}

Перші спроби симуляції еволюції були проведені у 1954 році Нільсом Баричеллі на комп'ютері, встановленому в Інституті перспективних досліджень Принстонського університету. Його робота, що була опублікована у тому ж році, привернула увагу громадськості. З 1957 року,  австралійський генетик Алекс Фразер опублікував серію робіт з симуляції штучного відбору серед організмів з множинним контролем вимірюваних характеристик. Це дозволило комп'ютерній симуляції еволюційних процесів та методам, які були описані у книгах Фразера та Барнела(1970) та Кросбі(1975), з 1960-х років стати більш розповсюдженим видом діяльності серед біологів. Симуляції Фразера містили усі найважливіші елементи сучасних генетичних алгоритмів. До того ж, Ганс-Іоахім Бремерман в 1960-х опублікував серію робіт, які також приймали підхід використання популяції рішень, що піддаються відбору, мутації та рекомбінації, в проблемах оптимізації. Дослідження Бремермана також містили елементи сучасних генетичних алгоритмів. Також варто відмітити Річарда Фрідберга, Джоржа Фрідмана та Майкла Конрада. \medskip

Хоча Баричеллі у своїй роботі 1963 р. займався симуляцією можливості машини грати у просту гру, штучна еволюція стала загальновизнаним методом оптимізації після роботи Інго Рехенберга та Ханса-Пауля Швереля у 60-х та на початку 70-х років двадцятого століття — група Рехенсберга змогла вирішити складні інженерні проблеми згідно зі стратегіями еволюції. Іншим підходом була техніка еволюційного програмування Лоренса Дж. Фогеля, яка була запропонована для створення штучного інтелекту. Еволюційне програмування, яке спочатку використовувало кінцеві автомати для передбачення обставин, та використовували різноманіття та відбір для оптимізації логіки передбачення. Генетичні алгоритми стали особливо відомі завдяки роботі Дж. Холанда на початку 70-х років та його книзі ``Адаптація у природніх та штучних системах'' (1975). Його дослідження були основані на експериментах з клітинними автоматами та на його роботах, що були написані в університеті Мічигану. Він ввів формалізований підхід для передбачення якості наступного покоління, відомий як Теорема схем. Дослідження в області генетичних алгоритмів залишалось більше теоретичним до середини 80-х років, коли була, нарешті, проведена Перша міжнародна конференція з генетичних алгоритмів (Піттсбург, Пенсильванія (США)). \medskip

З ростом дослідницького інтересу суттєво виросла обчислювальна потужність комп'ютерів, що дозволило використовувати нову обчислювальну техніку на практиці. Наприкінці 80-х років, компанія General Electric почала продаж першого в світі продукту, який працював з використанням генетичного алгоритму. Це був набір промислових обчислювальних засобів. В 1989 інша компанія Axcelis, Inc. випустила Evolver --- перший у світі комерційний продукт на генетичному алгоритмі для персональних комп'ютерів. Журналіст The New York Times в технологічній сфері Джон Маркофф писав про Evolver у 1990 році.

\subsection{Сфери застосування}

Задачі до яких особливо часто застосовується генетичний алгоритм включають складання розкладів, інженерські задачі\cite{tcs13}, розробка схеми сонячної електростанції\cite{gb13}, дизайн форми космічної антени\cite{hll}, розробка штучного опорно-рухового апарату для роботів\cite{robotwalking}, і, звичайно, аеродинамічний дизайн\cite{ew17}.

\subsection{Можливі модифікації}

\subsubsection{Елітаризм}

Ця модифікація передбачає, що найкращі особини переходять до нового покоління без мутації. Вона гарантує монотонне незростанняя результату генетичного алгоритму, але ускладнює вихід з локальних оптимумів.

\subsubsection{Паралельна реалізація}

Цілком очевидно, що алгоритм гарно паралелиться, для цього кожному комп'ютері в обчислювальному кластері доручають моделювання якоїсь малої частини усієї популяції, які мутують поодинці, схрещуються всередині комп'ютера. Щодо генерації нового покоління то зазвичай раз на кілька ітерацій нове покоління генерується одним центральним комп'ютером на основі результатів всіх інших комп'ютерів, а не просто всередині кожного окремого комп'ютеру.

\section{Формалізований опис алгоритму}

Нехай є певна фітнес-функція $f$: $\mathbb{R}^m \to \mathbb{R}$ і ставиться оптимцізаційна задача
\begin{equation}
    f(x) \xrightarrow[x \in \mathcal{C}]{} \min,
\end{equation}
де $\mathcal{C} \subset \mathbb{R}^m$ --- опукла і замкнена допустима множина, наприклад $\mathcal{C} = [x_{\text{min}}, x_{\text{max}}]^m$. \medskip

Розглянемо популяцію з $n$ особин які протягом $M$ поколінь розв'язують цю оптимізаційну задачу (пристосовуються під задану фітнес-функцію). Кожну особину будемо описувати двійковим вектором достатньо довгим для того щоб кодувати десяткові значення аргументів функції $x_i$ з потрібною точністю $\varepsilon$. \medskip

Перше покоління не має досвіду предків і генерується випадковим чином, рівномірно на $\mathcal{C}$. \medskip

Далі з кожним поколінням відбуваються наступні речі:
\begin{itemize}
    \item воно кодується з десяткового представлення у двійкове;
    \item у ньому із заданою ймовірністю $p$ відбувають бітові мутації;
    \item покоління розбивається на пари, між якими відбувається кроссовер (обмін генами);
    \item на основі покоління генерується нове таким чином що найкращі особини мають більшу ймовірність мати нащадка.
\end{itemize}

\section{Код програмного продукту}

\subsection{GenerationDec}

\subsubsection*{Призначення}

Ця процедура заповнює матрицю із заданою кількістю рядків і стовпчиків випадковими десятковими числами із заданого діапазону. \medskip

Діапазон значень фіксований для усіх елементів кожного стовпчика матриці. \medskip

Елементи останнього стовпчика матриці не заповнюються випадковими числами і призначені для обчислення значень фітнес-функції, аргументами якої є всі попередні елементи рядка матриці.

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $N, M$ --- цілі невід'ємні числа
    \item $X_{\text{min}}(1..M), X_{\text{max}}(1..M)$ --- масиви дійсних чисел, $X_{\text{min}}[i] < X_{\text{max}}[i]$, $i = \overline{1..M}$;
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item $G(1..N, 1..M+1)$ --- матриця випадкових значень.
\end{itemize}

\subsubsection*{Обчислення}

Заповнює елементи матриці $G[i,j]$, $i = \overline{1..N}$, $j = \overline{1..M}$, $X_{\text{min}}[j] \le G[i, j] \le X_{\text{max}}[j]$.

\subsubsection*{Вказівки}

Для генерування випадкових чисел з заданого діапазону використовувати функцію Generate пакета Random Tools.

\subsubsection*{Власне реалізація}

\inputminted[firstline=7, lastline=40]{python}{../code/generation_dec.py}

\subsection{Mutation}

\subsubsection*{Призначення}

Опрацьовує в циклі кожен елемент прямокутної матриці заданого розміру з елементами 0 або 1 за наступним правилом: 
\begin{itemize}
    \item якщо згенероване випадкове число менше заданого порогового значення, то відповідний елемент матриці інвертується (0 в 1 або 1 в 0);
    \item інакше елемент матриці не змінюється. 
\end{itemize}

Результат зберігається у новій матриці.

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $G$ --- прямокутна матриця зі значеннями 0 або 1;
    \item $p$ --- дійсне число $0 < p \ll 1$ --- ймовірність мутації.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item $G_{\text{mut}}$ --- прямокутна матриця зі значеннями 0 або 1, розмірність якої дорівнює розмірності $G$;
    \item $S_{\text{mut}}$ --- лічильних загальної кількості мутацій, що були виконані для матриці $G$.
\end{itemize}

\subsubsection*{Обчислення}

\begin{itemize}
    \item В циклі опрацювати кожен елемент матриці $G$, перевіряючи умову, що згенероване випадкове число менше заданого параметра $p$. 
    \item При виконанні умови виконати мутацію, інакше елемент матриці не змінюється. 
    \item При кожній мутації збільшувати лічильник на одиницю.
\end{itemize}

\subsubsection*{Вказівки}

Для генерування випадкових чисел з заданого діапазону можна використовувати функцію Generate з пакету Random Tools.

\subsubsection*{Власне реалізація}

\inputminted[firstline=6, lastline=15]{python}{../code/mutation.py}

\subsection{Crossover}

\subsubsection*{Призначення}

Процедура опрацьовує вхідну прямокутну матрицю з парною $2N$ кількістю рядків і довільною кількістю стовпчиків, елементами якої є числа 0 або 1. \medskip

Рядки матриці об'єднуються в пари, пари утворюються за значенням номерів рядків матриці, вказаними у двох списка розмірності $N$. \medskip

Кожна пара рядків матриці опрацьовується наступним чином:
\begin{itemize}
    \item Генерується випадкове ціле число $1 \le \text{cros} \le L$ --- кількість стовпчиків матриці. 
    \item Пара рядків матриці, яка зараз опрацьовується, обмінюється між собою елементами стовпчиків з номерами від $1$ до $\text{cros}$. 
    \item Результати записуються у нову матрицю, розмірність якої дорівнює розмірності вхідної матриці.
\end{itemize}

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $N$ --- ціле додатнє число;
    \item $G(1..2N,1..L)$ --- матриця з елементами 0 або 1;
    \item $M_{\text{list}}(1..N), F_{\text{list}}(1..N)$ --- списки цілих чисел зі значеннями в інтервалі від $1$ до $2N$.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item Матриця $G_{\text{cros}}(1..2N,1..L)$ з елементами 0 або 1 як результат процедури кроссовера (схрещування).
\end{itemize}

\subsubsection*{Обчислення}

\begin{itemize}
    \item Організується цикл по елементам списків $M_{\text{list}}[i], F_{\text{list}}[i]$, $i = \overline{1..N}$. 
    \item Послідовно опрацьовується кожна пара рядків $G[M_{\text{list}}[i],1..L]$ и $G[F_{\text{list}}[i],1..L]$. 
    \item Для кожної такої пари рядків генерується випадкове число $\text{cros}$ від $1$ до $L$. 
    \item Ці рядки обмінюються між собою елементами від $1$ до $\text{cros}$. 
    \item Результат змінених рядків записується у нову матрицю $G_{\text{cros}}(1..2N,1..L)$.
\end{itemize}

\subsubsection*{Вказівки}

\begin{itemize}
    \item Для генерування випадкових чисел з заданого діапазону можна використовувати функцію Generate з пакету Random Tools.
    \item Для обчислення кількості рядків або стовпчиків матриці можна використовувати функції RowDimension і ColumnDimension з пакету LinearAlgebra.
\end{itemize}

\subsubsection*{Власне реалізація}

\inputminted[firstline=5, lastline=30]{python}{../code/crossover.py}

\subsection{Parents}

\subsubsection*{Призначення}

послідовність натуральних чисел від $1$ до $2N$ розбивається на два списки натуральних чисел таким чином, що елементи кожгого списку вибираються випадковим чином з діапазону $[1..2N]$ з умовою, що елементи списків з одинаковими номерами різні.

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $N$ --- кількість елементів списків.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item Списки $m_{\text{list}}(1..N), f_{\text{list}}(1..N)$.
\end{itemize}

\subsubsection*{Обчислення}

\begin{itemize}
    \item Організується циклічний процес по всім елементам списку. 
    \item Елементам першого списку значення присвоють випадковим чином, а елементам другого списку випадковим чином, але з умовою, що $m_{\text{list}}[i] \ne f_{\text{list}}[i]$.
    \item При рівності робиться ще спроба присвоєння випадково числа до виконання умови.
\end{itemize}

\subsubsection*{Вказівки}

Для генерування випадкових чисел з заданого діапазону можна використовувати функцію Generate з пакету Random Tools.

\subsubsection*{Власне реалізація}

\inputminted[firstline=6, lastline=12]{python}{../code/parents.py}

\subsection{BinDecParam}

\subsubsection*{Призначення}

Це допоміжна процедура для CodBinary і CodDecimal, обчислює параметри для прямого і зворотнього перетворення із заданою точністю із заданого інтервалу дійсних чисел у бінарну послідовність. 

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $M$ --- розмірності масивів.
    \item $X_{\text{min}}(1..M)$ --- масив, де $X_{\text{min}}[j]$ --- мінімальне значення діапазону $j$;
    \item $X_{\text{max}}(1..M)$ --- масив, де $X_{\text{max}}[j]$ --- максимальне значення діапазону $j$;
    \item $\varepsilon$ --- точність представлення десяткових чисел двійковим кодом.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item $nn[i]$, $i = \overline{1..M}$ --- список цілих чисел, містить значення кількості бінарних розрядів які необхідні для кодування довільного дійсного числа з діапазону $[X_{\text{min}}[i], X_{\text{max}}[i]]$ з точністю $\varepsilon$.
    \item $dd[i]$, $i = \overline{1..M}$ --- дійсне число, містить значення дискретності для представлення дійсного числа із заданого діапазону цілим числом.
    \item $NN[j + 1] = \sum_{i = 1}^j nn[i]$, $j = \overline{1..M}$, $NN[1] = 0$ --- список цілих чисел.
\end{itemize}

\subsubsection*{Вказівки}

Всі вихідні параметри описуються з атрибутом global.

\subsubsection*{Обчислення}

\begin{align}
    nn[i] &= \left[ \log_2 \left( \frac{X_{\text{max}}[i] - X_{\text{min}}[i]}{\varepsilon} \right) \right] + 1, \quad i = \overline{1..M}, \\
    dd[i] &= \frac{X_{\text{max}}[i] - X_{\text{min}}[i]}{2^{nn[i]}} \le \varepsilon, \quad i = \overline{1..M}, \\
    NN[j + 1] &= \sum_{i = 1}^j nn[i], \quad j = \overline{1..M}, \quad NN[1] = 0.
\end{align}

\subsubsection*{Власне реалізація}

\inputminted[firstline=9, lastline=51]{python}{../code/bin_dec_param.py}

\subsection{CodBinary}

\subsubsection*{Призначення}

Процедура виконує кодування довільного дійсного числа $x_{\text{dec}}$ з заданого діапазону $[x_{\text{min}}..x_{\text{max}}]$ з заданою точністю $\varepsilon$ у послідовність з 0 і 1 фіксованої довжини. \medskip

Процедура працює у парі з процедурою CodDecimal, яка виконує зворотнє перетворення. \medskip

Допоміжні параметри обчислюються процедурою BinDecParam.

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $x_{\text{dec}}$ --- десяткове число;
    \item $x_{\text{min}}$ --- мінімальне значення числа, що кодується;
    \item $l$ --- ціле число, максимальна кількість двійкових розрядів для представлення довільного числа із заданого діапазону із заданою точністю;
    \item $d$ --- дискретність кодування дійсного числа $x_{\text{dec}}$ цілим числом.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item $X_{\text{bin}}$ --- список з $l$ розрядів двійкового числа, молодші розряді йдуть спочатку. 
\end{itemize}

У разі потреби старші розряди дозаповнюються нулями.

\subsubsection*{Обчислення}

Ціле число частин величини $d$ для заданого числа $x_{\text{dec}}$ можно обчислити як
\begin{equation}
    xx = \left[ \frac{x_{\text{dec}} - x_{\text{min}}}{d} \right].
\end{equation}

Ціле число $xx$ записуємо у двійковій формі і доповнюємо старші розряди нулями, якщо їхня кількість менше $l$.

\subsubsection*{Вказівки}

Значення $l$ і $d$ обчислюються процедурою BinDecParam і не можуть задаватися довільно. \medskip

Перетворення цілого десяткового числа у двійковий код (список 0 і 1) можна виконати функцією convert(xx, base, 2).

\subsubsection*{Власне реалізація}

\inputminted[firstline=7, lastline=28]{python}{../code/cod_binary.py}

\subsection{CodDecimal}

\subsubsection*{Призначення}

Процедура виконує перетворення закодованого послідовністю з 0 і 1 двійкового представлення числа з заданого діапазону $[x_{\text{min}}..x_{\text{max}}]$ із заданою точністю $\varepsilon$ у його звичайне десяткове представлення. \medskip

Процедура працює в парі з процедурою CodBinary, яка виконує зворотнє перетворення. 

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $x_{\text{bin}}$ --- послідовність розрядів двійкового числа;
    \item $x_{\text{min}}$ --- мінімальне значення десяткового числа;
    \item $d$ --- дискретність кодування дійсного чиисла $x_{\text{dec}}$ цілим числом.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item $x_{\text{dec}}$ --- десяткове число. 
\end{itemize}

\subsubsection*{Обчислення}

\begin{itemize}
    \item Послідовність розрядів $x_{\text{bin}}$ перетворюється у ціле число $x_{\text{dec}}'$. 
    \item Далі за допомогою цілого числа $d$ відновлюємо десяткове число $x_{\text{dec}} = x_{\text{min}} + d \cdot x_{\text{dec}}'$.
\end{itemize}

\subsubsection*{Вказівки}

Значення $l$ і $d$ обчислюються процедурою BinDecParam і не можуть задаватися довільно. \medskip

Перетворення двійкового коду (список 0 і 1) у послідовність десяткових розрядів цілого десяткового числа можна виконати функцією convert(xbin, base, 2, 10).

\subsubsection*{Власне реалізація}

\inputminted[firstline=9, lastline=24]{python}{../code/cod_decimal.py}

\subsection{ACodBinary}

\subsubsection*{Призначення}

Послідовно перетворює дійсні числа, а саме елементи матриці $G_{\text{dec}}(1..N,1..M+1)$, яка складається з $N$ рядків і $M + 1$ стовпчиків у двійковий код. \medskip

Перетворення виконуються над елементами тільки $M$ перших стовпчиків. \medskip

Для перетворення кожного елемента матриці використовуються процедури CodBinary і BinDecParam. \medskip

Результати перетворення дійсних чисел зберігаються у матрицю Gbin з елементами 0 або 1. \medskip

Кожному стовпчику матриці $G_{\text{dec}}$ відповідає фіксована кількість стовпчиків матриці $G_{\text{bin}}$, яка визначається діапазоном дійсних значень які кодуються і точністю їхнього представлення (див. процедуру CodBinary, параметр $l$).

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $N, M$ --- розмірності матриці $G_{\text{dec}}(1..N,1..M+1)$;
    \item Матриця $G_{\text{dec}}(1..N,1..M+1)$;
    \item $X_{\text{min}}(1..M)$ --- масив, де $X_{\text{min}}[j]$ --- мінімальне значення елементів стовпчика $j$;
    \item Глобальні параметри процедури BinDecParam: $nn, dd, NN$.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item Матриця $G_{\text{bin}}$ з елементами 0 або 1, яка складається з $N$ рядків, кількість стовпчиків матриці визначається значенням $NN \cdot (M + 1)$.
\end{itemize}

\subsubsection*{Обчислення}

В циклі опрацьовуємо кожний елемент матриці $G_{\text{dec}}$, використовуємо процедуру CodBinary, записуємо результати перетворення у матрицю $G_{\text{bin}}$ розмірності $(1..N, 1..NN \cdot [M+1])$.

\subsubsection*{Вказівки}

Використовувати для обробки кожного елемента вихідної матриці процедуру CodBinary.

\subsubsection*{Власне реалізація}

\inputminted[firstline=31, lastline=73]{python}{../code/cod_binary.py}

\subsection{ACodDecimal}

\subsubsection*{Призначення}

Опрацьовує вміст матриці $G_{\text{bin}}$ з елементами 0 або 1 використовуючи структуру матриці і перетворює послідовності з 0 і 1 заданих довжин у дійсні числа.

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $N, M$ --- розмірності матриці $G_{\text{dec}}(1..N,1..M+1)$;
    \item Матриця $G_{\text{bin}}$;
    \item $X_{\text{min}}(1..M)$ --- масив, де $X_{\text{min}}[j]$ --- мінімальное значення елемениів стовпчика $j$;
    \item Глобальні параметри $nn, dd, NN$ процедури BinDecParam.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item Матриця $G_{\text{dec}}(1..N,1..M+1)$.
\end{itemize}

\subsubsection*{Обчислення}

\begin{itemize}
    \item У циклі послідовно опрацьовуються всі рядки матриці $G_{\text{bin}}$. 
    \item З кожного рядка вибираються $M$ послідовностей з 0 і 1, які опрацьовує процедура CodDecimal. 
    \item Отримані дійсні числа записуються у матрицю $G_{\text{dec}}(1..N,1..M+1)$.
\end{itemize}

\subsubsection*{Власне реалізація}

\inputminted[firstline=27, lastline=66]{python}{../code/cod_decimal.py}

\subsection{Adapt}

\subsubsection*{Призначення}

Генерирує масив $N$ цілих невід'ємних чисел, сума яких дорівнює $N$. \medskip

Кожне значення з номером $j$ масиву обчислюється як кількість потраплянь випадкового числа рівномірно розподіленого на відрізку $[0..1]$ у підінтервал з номером $1 \le j \le N$, що належить відрізну $[0..1]$. \medskip

Сума довжин всіх підінтервалів дорівнює одиниці.

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $p$ --- послідовність $N$ дійсних чисел;
    \item $N$ --- ціле додатнє число.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item $\text{num}$ --- масив $N$ цілих невід'ємних чисел, сума яких дорівнює $N$.
\end{itemize}

\subsubsection*{Обчислення}

\begin{itemize}
    \item Перетворюємо послідовнітсь $p$:
    \begin{itemize}
        \item Знаходимо мінимальний елемент $p$.
        \item Віднімаємо від кожного елемента $p$ мінімальний елемент, утворюємо $p_1$.
    \end{itemize}
    \item Знаходимо суму всіх елементів $p_1$;
    \item Ділимо кожен елемент $p_1$ на суму значень його елементів, утворюємо $p_2$.
    \item Утворюємо список префіксних сум $p_2$:
	\begin{equation}
	    \text{adaptability} = [0, p_2[1], p_2[1] + p_2[2], \ldots, p_2[1] + p_2[2] + \ldots + p_2[N]].
	\end{equation}
    \item $N$ разів генеруємо випадкове число $0 \le \text{roll} < 1$ і перевіряємо умову належності випадкового числа $\text{roll}$ одному з діапазонів списку $\text{adaptability}$:
    \begin{itemize}
        \item Якщо $\text{adaptability}[j] \le \text{roll} < \text{adaptability}[j + 1]$, то $\text{num}[j] = \text{num}[j] + 1$.
    \end{itemize}
\end{itemize}

\subsubsection*{Вказівки}

Для генерування випадкових чисел з заданого діапазону можна використовувати функцію Generate з пакету Random Tools.

\subsubsection*{Власне реалізація}

\inputminted[firstline=6, lastline=31]{python}{../code/adapt.py}

\subsection{Best і Worst}

\subsubsection*{Призначення}

Процедури опрацьовують $(M+1)$-ий стовпчик матриці $G_{\text{dec}}$, який містить дійсні значення деякої функції від $M$ аргументів, самі аргументи містять у стовпчиках з $1$ по $M$.

\subsubsection*{Обчислення}

Процедура Best обчислює номер рядка з мінімальним значенням функції, а процедура Worst --- номер рядка з максимальним значенням функції. 

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $G_{\text{dec}}$ --- вищезгадана матриця.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item Кожна з процедур повертає знайдене ціле число.
\end{itemize}

\subsubsection*{Власне реалізація}

\inputminted[firstline=5, lastline=36]{python}{../code/best_worst.py}

\subsection{NewGeneration}

\subsubsection*{Призначення}

Опрацьовує рядки вхідної матриці виходячи зі значень вхідного цілочисельного масиву з невід'ємними елементами (сума елементов цілочисльного масиву дорівнює кількості рядків матриці). \medskip

Розмірність масива і кількість рядків матриці рівні. \medskip

Рядок з номером $j$ вхідної матриці записується у вихідну матрицю таку кількість разів, яка дорівнює цілому значенню з номером $j$ масива. \medskip

Якщо на позиції $j$ знаходиться число $0$, то рядок у вихідну матрицю не записується.

\subsubsection*{Вхідні параметри}

\begin{itemize}
    \item $G_{\text{dec}}(1..N,1..M+1)$ --- матриця;
    \item $\text{num}(1..N)$ --- масив цілочисльних значень.
\end{itemize}

\subsubsection*{Вихідні параметри}

\begin{itemize}
    \item $G_{\text{dec}_{\text{new}}}(1..N,1..M+1)$ --- вихідна матриця.
\end{itemize}

\subsubsection*{Власне реалізація}

\inputminted[firstline=5, lastline=11]{python}{../code/new_generation.py}

\subsection{Програма-драйвер}

\inputminted[lastline=42]{python}{../code/main.py}

\section{Тестування програмного продукту}

Окремо зауважимо, що для проводилося тестування окремих модулів за допомогою бібліотеки unittest. \medskip

Окрім цього, проводилося тестування цілісного алгоритму на багатовимірній (в $\RR^{20}$) функції Растрігіна. \medskip

Сильною стороною програмного продукту виявилася \textbf{швидкодія}: $2^{10}$ ітерацій з розміром популяції $2^{10}$ особин зайняли близько 13 хвилин, що більш ніж \textbf{у 2.5 рази швидше} за наступний по швидкодії код здатний працювати на задачах такого масштабу (Олексія Кравця). \medskip

Окрім цього алгоритм демонструє непогану динаміку точності:
\begin{verbatim}
C:\Users\NikitaSkybytskyi\Desktop\gen\gen\code>main.py
it 0001: -134.2913119
it 0002: -125.0144292
it 0003: -117.6224736
it 0004:  -99.8343776
it 0005:  -95.0405274
it 0006:  -95.0399947
it 0007:  -81.9499555
it 0008:  -68.6859237
.....................
it 0050:  -13.8048245
.....................
it 0100:   -7.4214788
.....................
it 0200:   -1.9735074
.....................
it 0500:   -0.5820756
.....................
it 1000:   -0.3860838
\end{verbatim}

% \newpage
\bibliography{main}
\bibliographystyle{ieeetr}

\end{document}